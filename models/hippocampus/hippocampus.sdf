<?xml version="1.0" ?>
<sdf version='1.5'>
  <!--
      Add a model named hippocampus, developed by the Technical University Hamburg-Harburg (TUHH),
      start with the first link, the base (hippocampus without rotors). The pose is relative to the given frame.
      https://www.tuhh.de/mum/forschung/forschungsgebiete-und-projekte/flow-field-estimation-with-a-swarm-of-auvs.html
  -->
  <model name='hippocampus'>
    <link name='base_link'>
      <pose>0 0 0 0 0 0</pose>
      <inertial>
        <pose>0 0 0 0 0 0</pose>
        <!--
          These values are a compromise between the dry mass and added mass
          values used to correct for hydrodynamic effects.
          Real values:  m = 1,47 kg; Ixx = 0,002408 kgm²; Iyy = Izz = 0.010717 kgm²
                        Xu = -1,11 kg; Yv = Zw = -2,8 kg; Kp = -0,00451 kgm²; Mq = Nr = -0,0163 kgm²
        -->
        <mass>3</mass>
        <inertia>
          <ixx>0.007</ixx>
          <ixy>0</ixy>
          <ixz>0</ixz>
          <iyy>0.027</iyy>
          <iyz>0</iyz>
          <izz>0.027</izz>
        </inertia>
      </inertial>
      <!--
         no self collision and no kinematics, since both are are modelled later (collision via a cylinder)
      -->
      <self_collide>0</self_collide>
      <kinematic>0</kinematic>
      <velocity_decay/>
      <gravity>0</gravity>
      <!--
          visual properties of the link, (here the base of the hippocampus)
      -->
      <visual name='visual'>
        <pose>0 0 0 0 0 0</pose>
        <geometry>
          <mesh>
            <uri>model://hippocampus/meshes/hippocampus.stl</uri>
          </mesh>
        </geometry>
        <material>
          <lighting>1</lighting>
          <script>
            <uri>__default__</uri>
            <name>Gazebo/DarkGrey</name>
          </script>
          <ambient>0.3 0.3 0.3 1</ambient>
          <diffuse>0.7 0.7 0.7 1</diffuse>
          <specular>0.01 0.01 0.01 1</specular>
          <emissive>0 0 0 1</emissive>
          <shader type='vertex'>
            <normal_map>__default__</normal_map>
          </shader>
        </material>
        <cast_shadows>1</cast_shadows>
        <transparency>0</transparency>
      </visual>

    <!-- RGB cylinders representing the resulting frame -->
    <visual name="frameX">
      <pose>0.1 0 0 0 1.57 0</pose>
          <geometry>
            <cylinder>
              <length>0.35</length>
              <radius>0.005</radius>
            </cylinder>
          </geometry>
          <material>
            <ambient>0.0 0.0 0.0 1</ambient>
            <diffuse>0.0 0.0 0.0 1</diffuse>
            <specular>0.0 0.0 0.0 1</specular>
            <emissive>1.0 0.0 0.0 1</emissive>
          </material>
    </visual>
    <visual name="frameY">
      <pose>0 0.1 0 -1.57 0 0</pose>
          <geometry>
            <cylinder>
              <length>0.25</length>
              <radius>0.005</radius>
            </cylinder>
          </geometry>
          <material>
            <ambient>0.0 0.0 0.0 1</ambient>
            <diffuse>0.0 0.0 0.0 1</diffuse>
            <specular>0.0 0.0 0.0 1</specular>
            <emissive>0.0 1.0 0.0 1</emissive>
          </material>
    </visual>
    <visual name="frameZ">
      <pose>0 0 0.1 0 0 0</pose>
          <geometry>
            <cylinder>
              <length>0.25</length>
              <radius>0.005</radius>
            </cylinder>
          </geometry>
          <material>
            <ambient>0.0 0.0 0.0 1</ambient>
            <diffuse>0.0 0.0 0.0 1</diffuse>
            <specular>0.0 0.0 0.0 1</specular>
            <emissive>0.0 0.0 1.0 1</emissive>
          </material>
    </visual>


      <!--
        No gravity since weight and draft force are equal for the hippocampus
        A collision cylinder is created which encapsulates the Hippocampus. This allows faster computation as
        simulations using the real mesh of the Hippocampus since the geometry is easier to handle
      -->
      <gravity>0</gravity>
      <collision name='base_link_collision'>
        <laser_retro>0</laser_retro>
        <max_contacts>10</max_contacts>
        <pose>0 0 0 0 1.570796 0</pose>
        <geometry>
          <cylinder>
            <radius>0.03</radius>
            <length>0.36</length>
          </cylinder>
        </geometry>
        <!--
            Here the surface attributes are defined for the colision cylinder
        -->
        <surface>
          <friction>
            <ode>
              <mu>1</mu>
              <mu2>1</mu2>
              <fdir1>0 0 0</fdir1>
              <slip1>0</slip1>
              <slip2>0</slip2>
            </ode>
          </friction>
          <bounce>
            <restitution_coefficient>0</restitution_coefficient>
            <threshold>1e+06</threshold>
          </bounce>
          <contact>
            <collide_without_contact>0</collide_without_contact>
            <collide_without_contact_bitmask>1</collide_without_contact_bitmask>
            <collide_bitmask>1</collide_bitmask>
            <ode>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
              <max_vel>0.01</max_vel>
              <min_depth>0</min_depth>
            </ode>
            <bullet>
              <split_impulse>1</split_impulse>
              <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
            </bullet>
          </contact>
        </surface>
      </collision>
    </link>

    <!--
        A new link is defined which hold the IMU (e.g. acceleration sensors, ...). For the simulation it is positioned
        at the center of the Hippocampus.
        The orientation of the IMU is chosen in regard to the orientation of the Body coordinate system of the
        HippoCampus. PX4 uses the data from the IMU to calculate the orientation. Therefore PX4 assumes a NED (North-
        East-Down) coordinate frame whereas Gazebo uses a ENU (East-North-Up) coordinate frame.
    -->
    <link name='hippocampus/imu_link'>
      <pose>0 0 0 3.1415 0 0</pose>
      <inertial>
        <pose>0 0 0 0 0 0</pose>
        <mass>0.015</mass>
        <inertia>
          <ixx>1e-05</ixx>
          <ixy>0</ixy>
          <ixz>0</ixz>
          <iyy>1e-05</iyy>
          <iyz>0</iyz>
          <izz>1e-05</izz>
        </inertia>
      </inertial>
      <self_collide>0</self_collide>
      <kinematic>0</kinematic>
      <gravity>0</gravity>
    </link>

    <!--
        Now the rotors are defined on which the forces and moments attack. They are positioned relative to the center
        of the Hippocampus. Also a collision cylinder will be defined for each rotor to reduce computation time.
    -->
    <!-- CCW 1-->
    <link name='rotor_0'>
      <pose>-0.05 -0.0481 -0.0481 0 0 0</pose>
      <self_collide>0</self_collide>
      <kinematic>0</kinematic>
      <velocity_decay/>
      <gravity>0</gravity>
      <visual name='rotor_0_visual'>
        <pose>0 0 0 0 0 0</pose>
        <geometry>
          <mesh>
            <scale>1 1 1</scale>
            <uri>model://hippocampus/meshes/hippocampus_prop.stl</uri>
          </mesh>
        </geometry>
        <material>
          <script>
            <name>Gazebo/DarkGrey</name>
            <uri>__default__</uri>
          </script>
          <ambient>0 0 1 1</ambient>
          <diffuse>0 0 1 1</diffuse>
          <specular>0 0 1 1</specular>
          <emissive>0 0 1 1</emissive>
          <shader type='vertex'>
            <normal_map>__default__</normal_map>
          </shader>
        </material>
        <cast_shadows>1</cast_shadows>
        <transparency>0</transparency>
      </visual>
      <collision name='rotor_0_collision'>
        <laser_retro>0</laser_retro>
        <max_contacts>10</max_contacts>
        <pose>0 0 0.02 0 0 0</pose>
        <geometry>
          <cylinder>
            <radius>0.02</radius>
            <length>0.06</length>
          </cylinder>
        </geometry>
        <surface>
          <friction>
            <ode>
              <mu>1</mu>
              <mu2>1</mu2>
              <fdir1>0 0 0</fdir1>
              <slip1>0</slip1>
              <slip2>0</slip2>
            </ode>
          </friction>
          <bounce>
            <restitution_coefficient>0</restitution_coefficient>
            <threshold>1e+06</threshold>
          </bounce>
          <contact>
            <collide_without_contact>0</collide_without_contact>
            <collide_without_contact_bitmask>1</collide_without_contact_bitmask>
            <collide_bitmask>1</collide_bitmask>
            <ode>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
              <max_vel>0.01</max_vel>
              <min_depth>0</min_depth>
            </ode>
            <bullet>
              <split_impulse>1</split_impulse>
              <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
            </bullet>
          </contact>
        </surface>
      </collision>
    </link>
    <!-- CW 2 -->
    <link name='rotor_1'>
      <pose>-0.05 +0.0481 -0.0481 0 0 0</pose>
      <self_collide>0</self_collide>
      <kinematic>0</kinematic>
      <velocity_decay/>
      <gravity>0</gravity>
      <visual name='rotor_1_visual'>
        <pose>0 0 0 0 0 0</pose>
        <geometry>
          <mesh>
            <scale>1 1 1</scale>
            <uri>model://hippocampus/meshes/hippocampus_prop.stl</uri>
          </mesh>
        </geometry>
        <material>
          <script>
            <name>Gazebo/DarkGrey</name>
            <uri>__default__</uri>
          </script>
          <ambient>0 0 1 1</ambient>
          <diffuse>0 0 1 1</diffuse>
          <specular>0 0 1 1</specular>
          <emissive>0 0 1 1</emissive>
          <shader type='vertex'>
            <normal_map>__default__</normal_map>
          </shader>
        </material>
        <cast_shadows>1</cast_shadows>
        <transparency>0</transparency>
      </visual>
      <collision name='rotor_1_collision'>
        <laser_retro>0</laser_retro>
        <max_contacts>10</max_contacts>
        <pose>0 0 0.02 0 0 0</pose>
        <geometry>
          <cylinder>
            <radius>0.02</radius>
            <length>0.06</length>
          </cylinder>
        </geometry>
        <surface>
          <friction>
            <ode>
              <mu>1</mu>
              <mu2>1</mu2>
              <fdir1>0 0 0</fdir1>
              <slip1>0</slip1>
              <slip2>0</slip2>
            </ode>
          </friction>
          <bounce>
            <restitution_coefficient>0</restitution_coefficient>
            <threshold>1e+06</threshold>
          </bounce>
          <contact>
            <collide_without_contact>0</collide_without_contact>
            <collide_without_contact_bitmask>1</collide_without_contact_bitmask>
            <collide_bitmask>1</collide_bitmask>
            <ode>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
              <max_vel>0.01</max_vel>
              <min_depth>0</min_depth>
            </ode>
            <bullet>
              <split_impulse>1</split_impulse>
              <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
            </bullet>
          </contact>
        </surface>
      </collision>
    </link>
    <!-- CCW 3 -->
    <link name='rotor_2'>
      <pose>-0.05 0.0481 0.0481 0 0 0</pose>
      <self_collide>0</self_collide>
      <kinematic>0</kinematic>
      <velocity_decay/>
      <gravity>0</gravity>
      <visual name='rotor_2_visual'>
        <pose>0 0 0 0 0 0</pose>
        <geometry>
          <mesh>
            <scale>1 1 1</scale>
            <uri>model://hippocampus/meshes/hippocampus_prop.stl</uri>
          </mesh>
        </geometry>
        <material>
          <script>
            <name>Gazebo/DarkGrey</name>
            <uri>__default__</uri>
          </script>
          <ambient>0 0 1 1</ambient>
          <diffuse>0 0 1 1</diffuse>
          <specular>0 0 1 1</specular>
          <emissive>0 0 1 1</emissive>
          <shader type='vertex'>
            <normal_map>__default__</normal_map>
          </shader>
        </material>
        <cast_shadows>1</cast_shadows>
        <transparency>0</transparency>
      </visual>
      <collision name='rotor_2_collision'>
        <laser_retro>0</laser_retro>
        <max_contacts>10</max_contacts>
        <pose>0 0 0.02 0 0 0</pose>
        <geometry>
          <cylinder>
            <radius>0.02</radius>
            <length>0.06</length>
          </cylinder>
        </geometry>
        <surface>
          <friction>
            <ode>
              <mu>1</mu>
              <mu2>1</mu2>
              <fdir1>0 0 0</fdir1>
              <slip1>0</slip1>
              <slip2>0</slip2>
            </ode>
          </friction>
          <bounce>
            <restitution_coefficient>0</restitution_coefficient>
            <threshold>1e+06</threshold>
          </bounce>
          <contact>
            <collide_without_contact>0</collide_without_contact>
            <collide_without_contact_bitmask>1</collide_without_contact_bitmask>
            <collide_bitmask>1</collide_bitmask>
            <ode>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
              <max_vel>0.01</max_vel>
              <min_depth>0</min_depth>
            </ode>
            <bullet>
              <split_impulse>1</split_impulse>
              <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
            </bullet>
          </contact>
        </surface>
      </collision>
    </link>
    <!-- CW 4 -->
    <link name='rotor_3'>
      <pose>-0.05 -0.0481 +0.0481 0 0 0</pose>
      <self_collide>0</self_collide>
      <kinematic>0</kinematic>
      <velocity_decay/>
      <gravity>0</gravity>
      <visual name='rotor_3_visual'>
        <pose>0 0 0 0 0 0</pose>
        <geometry>
          <mesh>
            <scale>1 1 1</scale>
            <uri>model://hippocampus/meshes/hippocampus_prop.stl</uri>
          </mesh>
        </geometry>
        <material>
          <script>
            <name>Gazebo/DarkGrey</name>
            <uri>__default__</uri>
          </script>
          <ambient>0 0 1 1</ambient>
          <diffuse>0 0 1 1</diffuse>
          <specular>0 0 1 1</specular>
          <emissive>0 0 1 1</emissive>
          <shader type='vertex'>
            <normal_map>__default__</normal_map>
          </shader>
        </material>
        <cast_shadows>1</cast_shadows>
        <transparency>0</transparency>
      </visual>
      <collision name='rotor_3_collision'>
        <laser_retro>0</laser_retro>
        <max_contacts>10</max_contacts>
        <pose>0 0 0.02 0 0 0</pose>
        <geometry>
          <cylinder>
            <radius>0.02</radius>
            <length>0.06</length>
          </cylinder>
        </geometry>
        <surface>
          <friction>
            <ode>
              <mu>1</mu>
              <mu2>1</mu2>
              <fdir1>0 0 0</fdir1>
              <slip1>0</slip1>
              <slip2>0</slip2>
            </ode>
          </friction>
          <bounce>
            <restitution_coefficient>0</restitution_coefficient>
            <threshold>1e+06</threshold>
          </bounce>
          <contact>
            <collide_without_contact>0</collide_without_contact>
            <collide_without_contact_bitmask>1</collide_without_contact_bitmask>
            <collide_bitmask>1</collide_bitmask>
            <ode>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
              <max_vel>0.01</max_vel>
              <min_depth>0</min_depth>
            </ode>
            <bullet>
              <split_impulse>1</split_impulse>
              <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold>
              <soft_cfm>0</soft_cfm>
              <soft_erp>0.2</soft_erp>
              <kp>1e+13</kp>
              <kd>1</kd>
            </bullet>
          </contact>
        </surface>
      </collision>
    </link>

    <!--
        Joints are defined which connects two links with kinematic and dynamic properties. Therefore all childs, thus
        the IMU and the rotors, are joint with the base_link, the base Hippocampus model
    -->
    <joint name='hippocampus/imu_joint' type='revolute'>
      <parent>base_link</parent>
      <child>hippocampus/imu_link</child>
      <axis>
        <xyz>1 0 0</xyz>
        <use_parent_model_frame>1</use_parent_model_frame>
        <limit>
          <lower>0</lower>
          <upper>0</upper>
          <effort>0</effort>
          <velocity>0</velocity>
        </limit>
        <dynamics>
          <spring_reference>0</spring_reference>
          <spring_stiffness>0</spring_stiffness>
          <damping>0</damping>
          <friction>0</friction>
        </dynamics>
      </axis>
      <physics>
        <ode>
          <limit>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </limit>
          <suspension>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </suspension>
        </ode>
      </physics>
    </joint>
    <joint name='rotor_0_joint' type='revolute'>
      <parent>base_link</parent>
      <child>rotor_0</child>
      <axis>
        <xyz>1 0 0</xyz>
        <use_parent_model_frame>1</use_parent_model_frame>
        <limit>
          <lower>-1e+16</lower>
          <upper>1e+16</upper>
          <effort>-1</effort>
          <velocity>-1</velocity>
        </limit>
        <dynamics>
          <spring_reference>0</spring_reference>
          <spring_stiffness>0</spring_stiffness>
          <damping>0</damping>
          <friction>0</friction>
        </dynamics>
      </axis>
      <physics>
        <ode>
          <limit>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </limit>
          <suspension>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </suspension>
        </ode>
      </physics>
    </joint>
    <joint name='rotor_1_joint' type='revolute'>
      <parent>base_link</parent>
      <child>rotor_1</child>
      <axis>
        <xyz>1 0 0</xyz>
        <use_parent_model_frame>1</use_parent_model_frame>
        <limit>
          <lower>-1e+16</lower>
          <upper>1e+16</upper>
          <effort>-1</effort>
          <velocity>-1</velocity>
        </limit>
        <dynamics>
          <spring_reference>0</spring_reference>
          <spring_stiffness>0</spring_stiffness>
          <damping>0</damping>
          <friction>0</friction>
        </dynamics>
      </axis>
      <physics>
        <ode>
          <limit>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </limit>
          <suspension>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </suspension>
        </ode>
      </physics>
    </joint>
    <joint name='rotor_2_joint' type='revolute'>
      <parent>base_link</parent>
      <child>rotor_2</child>
      <axis>
        <xyz>1 0 0</xyz>
        <use_parent_model_frame>1</use_parent_model_frame>
        <limit>
          <lower>-1e+16</lower>
          <upper>1e+16</upper>
          <effort>-1</effort>
          <velocity>-1</velocity>

        </limit>
        <dynamics>
          <spring_reference>0</spring_reference>
          <spring_stiffness>0</spring_stiffness>
          <damping>0</damping>
          <friction>0</friction>
        </dynamics>
      </axis>
      <physics>
        <ode>
          <limit>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </limit>
          <suspension>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </suspension>
        </ode>
      </physics>
    </joint>
    <joint name='rotor_3_joint' type='revolute'>
      <parent>base_link</parent>
      <child>rotor_3</child>
      <axis>
        <xyz>1 0 0</xyz>
        <use_parent_model_frame>1</use_parent_model_frame>
        <limit>
          <lower>-1e+16</lower>
          <upper>1e+16</upper>
          <effort>-1</effort>
          <velocity>-1</velocity>
        </limit>
        <dynamics>
          <spring_reference>0</spring_reference>
          <spring_stiffness>0</spring_stiffness>
          <damping>0</damping>
          <friction>0</friction>
        </dynamics>
      </axis>
      <physics>
        <ode>
          <limit>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </limit>
          <suspension>
            <cfm>0</cfm>
            <erp>0.2</erp>
          </suspension>
        </ode>
      </physics>
    </joint>

    <!--
        Now the plugins which are called by the simulation are defined. Also important parameters such as the transition
        from motor command to real force are defined.
    -->
    <static>0</static>
    <allow_auto_disable>1</allow_auto_disable>
    <plugin name="gps_plugin" filename="libgazebo_gps_plugin.so">
        <robotNamespace></robotNamespace>
        <gpsNoise>true</gpsNoise>
    </plugin>

    <!--
        The gazebo_mavlink_plugin.cpp is called. Parameters are transferred.
    -->
    <plugin name='mavlink_interface' filename='librotors_gazebo_mavlink_interface.so'>
      <robotNamespace>hippocampus</robotNamespace>
      <imuSubTopic>/imu</imuSubTopic>
      <gpsSubTopic>/gps</gpsSubTopic>
      <mavlink_addr>INADDR_ANY</mavlink_addr>
      <mavlink_udp_port>14560</mavlink_udp_port>
      <serialEnabled>false</serialEnabled>
      <serialDevice>/dev/ttyACM0</serialDevice>
      <baudRate>921600</baudRate>
      <qgc_addr>INADDR_ANY</qgc_addr>
      <qgc_udp_port>14550</qgc_udp_port>
      <hil_mode>false</hil_mode>
      <hil_state_level>false</hil_state_level>
      <motorSpeedCommandPubTopic>/gazebo/command/motor_speed</motorSpeedCommandPubTopic>

      <!-- control channels, this way for every channel different settings can be realized -->
      <control_channels>
        <channel name='rotor1'>
          <input_index>0</input_index>
          <input_offset>0</input_offset>
          <input_scaling>1</input_scaling>
          <zero_position_disarmed>0</zero_position_disarmed>
          <zero_position_armed>0</zero_position_armed>
          <joint_control_type>velocity</joint_control_type>
        </channel>
        <channel name='rotor2'>
          <input_index>1</input_index>
          <input_offset>0</input_offset>
          <input_scaling>1</input_scaling>
          <zero_position_disarmed>0</zero_position_disarmed>
          <zero_position_armed>0</zero_position_armed>
          <joint_control_type>velocity</joint_control_type>
        </channel>
        <channel name='rotor3'>
          <input_index>2</input_index>
          <input_offset>0</input_offset>
          <input_scaling>1</input_scaling>
          <zero_position_disarmed>0</zero_position_disarmed>
          <zero_position_armed>0</zero_position_armed>
          <joint_control_type>velocity</joint_control_type>
        </channel>
        <channel name='rotor4'>
          <input_index>3</input_index>
          <input_offset>0</input_offset>
          <input_scaling>1</input_scaling>
          <zero_position_disarmed>0</zero_position_disarmed>
          <zero_position_armed>0</zero_position_armed>
          <joint_control_type>velocity</joint_control_type>
        </channel>
      </control_channels>

    </plugin>

    <!--
        The gazebo_uvv_plugin is called. Parameters such as the namespace or addedMass are transferred.
    -->
    <plugin name='uuv_plugin' filename='libgazebo_uuv_plugin.so'>
      <robotNamespace>hippocampus</robotNamespace>
      <commandSubTopic>/gazebo/command/motor_speed</commandSubTopic>
      <linkName>base_link</linkName>
      <motorForceConstant>3</motorForceConstant>
      <motorTorqueConstant>0.02</motorTorqueConstant>

      <!-- Parameters for the simulation -->

      <!--
        Added Mass Matrix as two vectors in order to define the diagonal
        Real Values: Xu = -1,11 kg; Yv = Zw = -2,8 kg; Kp = -0,00451 kgm²; Mq = Nr = -0,0163 kgm²
      -->
      <addedMassLinear>1.11 2.8 2.8</addedMassLinear>
      <addedMassAngular>0.00451 0.0163 0.0163</addedMassAngular>

      <!--
        Damping Matrix as two vectors in order to define the diagonal
        Real Values:
      -->
      <dampingLinear>5.39 17.36 17.36</dampingLinear>
      <dampingAngular>0.00114 0.007 0.007</dampingAngular>

    </plugin>

    <!--
        The gazebo_imu_plugin.cpp is called.
    -->
    <plugin name='rotors_gazebo_imu_plugin' filename='librotors_gazebo_imu_plugin.so'>
      <robotNamespace>hippocampus</robotNamespace>
      <linkName>hippocampus/imu_link</linkName>
      <imuTopic>/imu</imuTopic>
      <gyroscopeNoiseDensity>0.0003394</gyroscopeNoiseDensity>
      <gyroscopeRandomWalk>3.8785e-05</gyroscopeRandomWalk>
      <gyroscopeBiasCorrelationTime>1000.0</gyroscopeBiasCorrelationTime>
      <gyroscopeTurnOnBiasSigma>0.0087</gyroscopeTurnOnBiasSigma>
      <accelerometerNoiseDensity>0.004</accelerometerNoiseDensity>
      <accelerometerRandomWalk>0.006</accelerometerRandomWalk>
      <accelerometerBiasCorrelationTime>300.0</accelerometerBiasCorrelationTime>
      <accelerometerTurnOnBiasSigma>0.196</accelerometerTurnOnBiasSigma>
    </plugin>

    <!--
        The gazebo_motor_model.cpp is called.
        Forces and Moments are set to zero since they are already calculated using the gazebo_uuv_plugin.
        The motor model plugins can be removed if you don't need the rotors to spin.
    -->
    <plugin name='front_right_motor_model' filename='librotors_gazebo_motor_model.so'>
      <robotNamespace>hippocampus</robotNamespace>
      <jointName>rotor_0_joint</jointName>
      <linkName>rotor_0</linkName>
      <turningDirection>ccw</turningDirection>
      <timeConstantUp>0.0125</timeConstantUp>
      <timeConstantDown>0.025</timeConstantDown>
      <maxRotVelocity>838</maxRotVelocity>
      <motorConstant>0.0</motorConstant>
      <momentConstant>0.0</momentConstant>
      <commandSubTopic>/gazebo/command/motor_speed</commandSubTopic>
      <motorNumber>0</motorNumber>
      <rotorDragCoefficient>0.0</rotorDragCoefficient>
      <rollingMomentCoefficient>0.0</rollingMomentCoefficient>
      <motorSpeedPubTopic>motor_speed/0</motorSpeedPubTopic>
      <rotorVelocitySlowdownSim>0.05</rotorVelocitySlowdownSim>
    </plugin>
    <plugin name='back_left_motor_model' filename='librotors_gazebo_motor_model.so'>
      <robotNamespace>hippocampus</robotNamespace>
      <jointName>rotor_1_joint</jointName>
      <linkName>rotor_1</linkName>
      <turningDirection>cw</turningDirection>
      <timeConstantUp>0.0125</timeConstantUp>
      <timeConstantDown>0.025</timeConstantDown>
      <maxRotVelocity>838</maxRotVelocity>
      <motorConstant>0.0</motorConstant>
      <momentConstant>0.0</momentConstant>
      <commandSubTopic>/gazebo/command/motor_speed</commandSubTopic>
      <motorNumber>1</motorNumber>
      <rotorDragCoefficient>0.0</rotorDragCoefficient>
      <rollingMomentCoefficient>0.0</rollingMomentCoefficient>
      <motorSpeedPubTopic>motor_speed/1</motorSpeedPubTopic>
      <rotorVelocitySlowdownSim>0.05</rotorVelocitySlowdownSim>
    </plugin>
    <plugin name='front_left_motor_model' filename='librotors_gazebo_motor_model.so'>
      <robotNamespace>hippocampus</robotNamespace>
      <jointName>rotor_2_joint</jointName>
      <linkName>rotor_2</linkName>
      <turningDirection>ccw</turningDirection>
      <timeConstantUp>0.0125</timeConstantUp>
      <timeConstantDown>0.025</timeConstantDown>
      <maxRotVelocity>838</maxRotVelocity>
      <motorConstant>0.0</motorConstant>
      <momentConstant>0.0</momentConstant>
      <commandSubTopic>/gazebo/command/motor_speed</commandSubTopic>
      <motorNumber>2</motorNumber>
      <rotorDragCoefficient>0.0</rotorDragCoefficient>
      <rollingMomentCoefficient>0.0</rollingMomentCoefficient>
      <motorSpeedPubTopic>motor_speed/2</motorSpeedPubTopic>
      <rotorVelocitySlowdownSim>0.05</rotorVelocitySlowdownSim>
    </plugin>
    <plugin name='back_right_motor_model' filename='librotors_gazebo_motor_model.so'>
      <robotNamespace>hippocampus</robotNamespace>
      <jointName>rotor_3_joint</jointName>
      <linkName>rotor_3</linkName>
      <turningDirection>cw</turningDirection>
      <timeConstantUp>0.0125</timeConstantUp>
      <timeConstantDown>0.025</timeConstantDown>
      <maxRotVelocity>838</maxRotVelocity>
      <motorConstant>0.0</motorConstant>
      <momentConstant>0.0</momentConstant>
      <commandSubTopic>/gazebo/command/motor_speed</commandSubTopic>
      <motorNumber>3</motorNumber>
      <rotorDragCoefficient>0.0</rotorDragCoefficient>
      <rollingMomentCoefficient>0.0</rollingMomentCoefficient>
      <motorSpeedPubTopic>motor_speed/3</motorSpeedPubTopic>
      <rotorVelocitySlowdownSim>0.05</rotorVelocitySlowdownSim>
    </plugin>
  </model>
</sdf>
